=t=HTTP Clients=t=

At this point, you should be fairly well-acquainted with some of the general concepts involved in using an HTTP client. This chapter will review some of the more popular mainstream client libraries, particularly common use cases and the advantages and disadvantages of each. It will also include information on how to write your own client in PHP should no alternatives appeal to you.

=1=HTTP Streams Wrapper=1=

PHP 4.3 saw the addition of the Streams extension to the core. According to the related section of the PHP manual, the intention was to provide "a way of generalizing file, network, data compression, and other operations which share a common set of functions and uses." Streams introduced several concepts, one of which is a wrapper. The job of a wrapper is to define how a stream handles communications in a specific protocol or using a specific encoding. One such protocol for which a wrapper is available is HTTP.

The advantage to the HTTP streams wrapper is that there is very little to learn in terms of the API. It's fairly easy to get something simple working quickly. The disadvantage is that it's very minimalistic in terms of the feature set offered. It gives you the ability to send HTTP requests without having to construct them entirely on your own (by specifying the body and optionally any headers you want to add) and access data in the response. That's about it. The ability to debug requests is one example of a feature that it does not include at the time of writing.

The fact that the wrapper is written in C is a bit of a double-edged sword. On the positive side, there is a substantial performance difference between C code and PHP code (though it is more noticeable in a high load environment). On the negative side, you have to either know C or depend on the community to deliver patches in a timely fashion for any issues that may arise. This also applies to extensions written in C that will be covered in subsequent sections.

The streams wrapper is part of the PHP core and as such has no installation requirements beyond that of PHP itself.

=2=A Simple Request and Response Handling=2=

Here's a simple example of the HTTP streams wrapper in action.

<code php>
<?php
$response = file_get_contents('http://localhost.example');
print_r($http_response_header);
</code>

A few things to note:
- The ''allow_url_fopen'' PHP configuration setting must be enabled for this to work, which it is in most environments.
- In this example, the ''file_get_contents'' function call is equivalent to making a GET request for the specified URL '''http://localhost.example'''.
- ''$response'' will contain the response body after the call to the ''file_get_contents'' function completes.
- ''$http_response_header'' is implicitly populated with the HTTP response status line and headers after the ''file_get_contents'' call because it uses the HTTP streams wrapper //within the current scope//.

While this example does work, it violates a core principle of good coding practices: no unexpected side effects. The origin of ''$http_response_header'' is not entirely obvious because PHP populates it implicitly. Additionally, it's more restrictive because the variable is only populated within the scope containing the call to ''file_get_contents''. Here's a better way to get access to the same data from the response headers.

<code php>
<?php
$handle = fopen('http://localhost.example', 'r');
$response = stream_get_contents($handle);
$meta = stream_get_meta_data($handle);
print_r($meta['wrapper_data']);
</code>

Stepping through this:
- The resource ''$handle'' is created to read from the URL '''http://localhost.example'''.
- The ''stream_get_contents'' function is called to read the remaining data on the stream pointed to by the ''$handle'' resource into ''$response''.
- The ''stream_get_meta_data'' function is called to read metadata for the stream pointed to by the ''$handle'' resource into ''$meta''.
- The '''wrapper_data''' index of the ''$meta'' array outputs the same array as ''$http_response_header'' would within the current scope. So long as ''$handle'' is accessible within the current scope, stream_get_meta_data() can be called on it. This makes it more flexible than '$http_response_header''.

=2=Stream Contexts and POST Requests=2=

Another concept introduced by streams is the context, which is basically a set of configuration options used in a streams operation. A context is created by passing an associative array of context options and their corresponding values to the ''stream_context_create'' function. One use of contexts with regard to the HTTP streams wrapper is making POST requests, as the wrapper uses the GET method by default.

<code php>
<?php
$context = stream_context_create(array(
    'http' => array(
        'method' => 'POST',
        'header' => implode("\r\n", array(
            'Content-Type: application/x-www-form-urlencoded',
            'Referer: http://localhost.example'
        )),
        'content' => http_build_query(array(
            'param1' => 'value1',
            'param2' => 'value2'
        ))
    )
));

$response = file_get_contents(
    'http://localhost.example/process',
    false,
    $context
);
</code>

In this example:
- '''http''' is the streams wrapper being used.
- '''POST''' is the HTTP method of the request.
- The '''header''' stream context setting is populated with a string containing HTTP header key-value pairs, in this case for the Content-Type and Referer HTTP headers. The Content-Type header is used to indicate that the request body data is URL-encoded. When multiple custom headers are needed, they must be separated by a carriage return-line feed ("\r\n" also known as CRLF) sequences. The ''implode'' function is useful for this if key-value pairs for headers are stored in an enumerated array.
- The ''http_build_query'' function is being used to construct the body of the request. This function can also be used to construct query strings of URLs for GET requests.
- '''http://localhost.example/process''' is the URL of the resource being requested.
- ''file_get_contents'' is called to execute the request, the options for which are passed via the created context ''$context''.
- The body of the response is returned and stored in the variable ''$response''.

=2=To Err and Not To Err=2=

Before PHP 5.3.0, an HTTP streams wrapper operation resulting in an HTTP error response (i.e. a 4xx or 5xx status code) causes a PHP-level warning to be emitted. This warning will only contain the HTTP version, the status code, and the status code description. The function calls for such operations generally return ''false'' as a result and leave you without a stream resource to check for more information. Here's an example of how to get what data you can.

<code php>
<?php
function error_handler($errno, $errstr, $errfile, $errline,
    array $errcontext) {

    // $errstr will contain something like this:
    // fopen(http://localhost.example/404): failed to open stream: 
    // HTTP request failed! HTTP/1.0 404 Not Found

    if ($httperr = strstr($errstr, 'HTTP/')) {

        // $httperr will contain HTTP/1.0 404 Not Found in the case
        // of the above example, do something useful with that here
    }
}

set_error_handler('error_handler', E_WARNING);

// If the following statement fails, $stream will be assigned false
// and error_handler will be called automatically
$stream = fopen('http://localhost.example/404', 'r');

// If error_handler() does not terminate the script, control will
// be returned here once it completes its execution
restore_error_handler();
</code>

This situation has been improved somewhat in PHP 5.3 with the addition of the ''ignore_errors'' context setting. When this setting is set to ''true'', operations resulting in errors are treated the same way as successful operations. Here's an example of what that might look like.

<code php>
<?php
$context = stream_context_create(
    array(
        'http' => array(
            'ignore_errors' => true
        )
    )
);

$stream = fopen('http://localhost.example/404', 'r', false, $context);

// $stream will be a stream resource at this point regardless of
// the outcome of the operation
$body = stream_get_contents($stream);
$meta = stream_get_meta_data($stream);

// $meta['wrapper_data'][0] will equal something like HTTP/1.0 404
// Not Found at this point, with subsequent array elements being
// other headers
$response = explode(' ', $meta['wrapper_data'][0], 3);
list($version, $status, $description) = $response;
switch (substr($status, 0, 1)) {
    case '4':
    case '5':
        $result = false;
    default:
        $result = true;
}
</code>

=2=Few More Options, Then Do-It-Yourself=2=

Below are a few other stream context options for the HTTP streams wrapper that may prove useful.

- '''user_agent''' allows you to set the user agent string to use in the operation. This can also be set manually by specifying a value for the User-Agent header in the '''header''' context option value.
- '''max_redirects''' is used to set the maximum number of redirections that the operation will process prior to assuming that the application is misbehaving and terminating the request. This option is only available in PHP 5.1.0 and up and uses a default value of 20.
- ''timeout'' is used to set a maximum limit on the amount of time in seconds that a read operation may be allowed to execute before it is terminated. It defaults to the value of the ''default_socket_timeout'' PHP configuration setting.

All other features utilizing headers must be implemented manually by specifying request headers in the '''header''' context option and checking either ''$http_response_header'' or the '''wrapper_data''' index of the array returned by the ''stream_get_meta_data'' function for response headers. 

{{HTTP Streams Wrapper in the PHP Manual

For more information about the HTTP streams wrapper itself, see http://www.php.net/manual/en/wrappers.http.php.
For details about the context options specific to the wrapper, see http://www.php.net/manual/en/context.http.php.}}

=1=cURL Extension=1=

The cURL PHP extension, available since PHP 4.0.2, wraps a library called libcurl that implements client logic for a variety of internet protocols including HTTP and HTTPS. Its API is fairly small and applications of it consist mostly of calls to set configuration options and their respective values.

cURL assumes fewer default configuration values than the HTTP streams wrapper, like whether or not to process redirections and how many of them to process. The disadvantage to this is that, combined with the rich feature set of the extension, PHP code to use cURL is often more verbose than equivalent code using other client libraries.

Like the streams wrapper, the cURL extension is written in C and has the same pros and cons in that respect. cURL uses a session handle (of the PHP resource data type) with which configuration settings can be associated in a similar fashion to how they are associated with contexts for stream wrappers. Also like stream contexts, cURL session handles can be used multiple times to repeat the same operation until passed to the ''curl_close'' function.

The cURL extension is included in the PHP core, but must either be compiled into PHP or installed as a separate extension. Depending on the runtime environment's operating system, this may involve installing a package in addition to the OS PHP package.

{{cURL in the PHP Manual

For more information on the cURL extension, see http://php.net/manual/en/book.curl.php.
For information on installing the cURL extension, see http://php.net/manual/en/curl.installation.php.
For information on the cURL extension configuration constants, see http://php.net/manual/en/function.curl-setopt.php.}}

=2=Same Story, Second Verse=2=

<code php>
<?php
$ch = curl_init('http://localhost.example/');
curl_setopt($ch, CURLOPT_RETURNTRANSER, true);
$response = curl_exec($ch);
curl_close($ch);
</code>

Going line by line again:
- ''curl_init'' is called and passed '''http://localhost.example/path/to/form''' as the URL for the request. Note this parameter is optional and can also be specified by calling ''curl_setopt'' with the cURL session handle (''$ch'' in this case), the ''CURLOPT_URL'' constant, and the URL string.
- ''curl_setopt'' is called to set the configuration setting represented by the ''CURLOPT_RETURNTRANSFER'' client to have a value of ''true''. This setting will cause ''curl_exec'' to return the HTTP response in a string rather than outputting it directly.
-- ''curl_exec'' is called to have it execute the request and return the response.
-- ''curl_close'' is called to explicitly close the cURL session handle, which will no longer be reusable after that point.

A useful setting worth mentioning early on is ''CURLOPT_VERBOSE'', which outputs debugging information when set to ''true''. This output is sent to either stderr (the default) or the file referenced by the value of the ''CURLOPT_STDERR''.

=2=Contrasting GET and POST=2=

Obviously the cURL extension has other functions, but by and large most HTTP requests made using the cURL extension will follow the sequence of operations shown in the above examples. Let's compare this with a POST request.

<code php>
<?php
$data = array(
    'param1' => 'value1',
    'param2' => 'value2',
    'file1' => '@/path/to/file',
    'file2' => '@/path/to/other/file'
);

$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://localhost.example/process');
curl_setopt($ch, CURLOPT_POST, true);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$response = curl_exec($ch);
curl_close($ch);
</code>

Differences between this and the previous example:
- The URL is passed using the ''curl_setopt'' function this time, just to show how to do it without passing it to the ''curl_init'' function. This is important when reusing cURL session handles with different URLs.
- ''CURLOPT_POST'' is set to ''true'' to change the request method to POST.
- ''CURLOPT_POSTFIELDS'' is an associative array or preformatted query string to be used as the data for the request body. Files can be uploaded by specifying a value where the first character is ''@'' and the remainder of the value is a filesystem path to the file intended for upload. 

Here are a few other cURL configuration setting constants related to the request method.
- ''CURLOPT_HTTPGET'': Boolean that, when set to ''true'', explicitly resets the request method to GET if it's been changed from the default.
- ''CURLOPT_NOBODY'': Boolean that, when set to ''true'', excludes the body from the response by changing the request method to GET.
- ''CURLOPT_PUT'': Boolean that, when set to ''true'', sets the request method to PUT for file uploads.
- ''CURLOPT_CUSTOMREQUEST'': String used to set the request method to one without its own corresponding CURLOPT constant, such as DELETE.

=2=Setting Multiple Options=2=

If you're working with PHP 5.1.3+ you have access to the ''curl_setopt_array'' function, which allows you to pass in an associative array of setting-value values to set with a single call. If you're working with an older version of PHP, the function is relatively easy to write. 

Using this function results in not only less and cleaner code, but in the case of the native C function it also results in fewer function calls and by proxy improved performance.

<code php>
<?php
if (!function_exists('curl_setopt_array')) {
    function curl_setopt_array($ch, array $options) {
        foreach ($options as $setting => $value) {
            curl_setopt($ch, $setting, $value);
        }
    }
}

$ch = curl_init();
$opts = array(
    CURLOPT_URL => 'http://localhost.example',
    CURLOPT_RETURNTRANSFER => true
);
curl_setopt_array($ch, $opts);
$response = curl_exec($ch);
curl_close($ch);
</code>

=2=Handling Headers=2=

''CURLOPT_HEADER'' holds a boolean flag that, when set to ''true'', will cause headers to be included in the response string returned by ''curl_exec''. 

Another option for getting at some of the data included in the response headers, such as the HTTP response code, is to use the ''curl_getinfo'' function as shown in the following example. For more on what other information this function offers, see its entry in the PHP manual.

<code php>
<?php
$ch = curl_init();
// ...
$response = curl_exec($ch);
$info = curl_getinfo($ch);
$responsecode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
</code>

''CURLOPT_HTTPHEADER'' holds an enumerated array of custom request header name-value pairs formatted like so.

<code php>
<?php
$ch = curl_init();
curl_setopt_array($ch, CURLOPT_HTTPHEADER, array(
    'Accept-Language: en-us,en;q=0.5',
    'Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7',
    'Keep-Alive: 300',
    'Connection: keep-alive'
));
</code>

=2=Debugging Requests=2=

Previously mentioned in the last section on handling headers, the ''curl_getinfo'' function also enables you to view requests being sent by cURL. This can be quite useful when debugging. Below is an example of this feature in action.

<code php>
<?php
$ch = curl_init();
curl_setopt_array(array(
    CURLOPT_RETURNTRANSFER => true,
    CURLINFO_HEADER_OUT => true
));
curl_exec($ch);
$request = curl_getinfo($ch, CURLINFO_HEADER_OUT);
</code>

- ''CURLOPT_RETURNTRANSFER'' is set to ''true'' in the ''curl_setopt_array'' call even though the return value of ''curl_exec'' isn't captured. This is simply to prevent unwanted output.
- ''CURLINFO_HEADER_OUT'' is set to ''true'' in the ''curl_setopt_array'' call to indicate that the request should be retained because it will be extracted after the request is made.
- ''CURLINFO_HEADER_OUT'' is specified in the ''curl_getinfo'' call to limit its return value to a string containing the request that was made.

=2=Cookies=2=

<code php>
<?php
$cookiejar = '/path/to/file';

$ch = curl_init();

$url = 'http://localhost.example';
curl_setopt($ch, CURLOPT_URL, $url); 
curl_setopt($ch, CURLOPT_COOKIEJAR, $cookiejar);
curl_exec($ch);

$url = 'http://localhost.example/path/to/form';
curl_setopt($ch, CURLOPT_URL, $url); 
curl_setopt($ch, CURLOPT_COOKIEFILE, $cookiejar);
curl_exec($ch);

curl_close($ch);
</code>

Here's a quick list of pertinent points:
- After the first ''curl_exec'' call, cURL will have stored the value of the the Set-Cookie response header returned by the server in the file referenced by '''/path/to/file''' on the local filesystem as per the ''CURLOPT_COOKIEJAR'' setting. This setting value will persist through the second ''curl_exec'' call.
- When the second ''curl_exec'' call takes place, the ''CURLOPT_COOKIEFILE'' setting will also point to '''/path/to/file'''. This will cause cURL to read the contents of that file and use it as the value for the Cookie request header when the request is constructed.
- If ''$cookiejar'' is set to an empty string, cookie data will persist in memory rather than a local file. This improves performance (memory access is faster than disk) and security (file storage may be more open to access by other users and processes than memory depending on the server environment).

In some instances it may be desirable for the ''CURLOPT_COOKIEJAR'' value to have a different value per request, such as for debugging. In most cases, however, ''CURLOPT_COOKIEJAR'' will be set for the first request to receive the initial cookie data and its value will persist for subsequent requests. In most cases, ''CURLOPT_COOKIEFILE'' will be assigned the same value as ''CURLOPT_COOKIEJAR'' after the first request. This will result in data being read from the file to include in the request, followed by cookie data from the response being written back to the file (and overwriting any existing data in that file) for use in subsequent requests. On a related note, if you want cURL to begin a new session in order to have it discard data for session cookies (i.e. cookies without an expiration date), you can set the ''CURLOPT_COOKIESESSION'' setting to ''true''.

If you want to handle cookie data manually for any reason, you can set the value of the Cookie request header via the ''CURLOPT_COOKIE'' setting. To get access to the response headers, set the ''CURLOPT_HEADER'' and ''CURLOPT_RETURNTRANSFER'' settings to ''true''. This will cause the ''curl_exec'' call to return the entire response including the headers and the body. Recall that there is a single blank line between the headers and the body and that a colon separates each header name from its corresponding value. This information combined with the basic string handling functions in PHP should be all you need. Also, you'll need to set ''CURLOPT_FOLLOWLOCATION'' to ''false'' in order to prevent cURL from processing redirections automatically. Not doing this would cause any cookies set by requests resulting in redirections to be lost.

=2=HTTP Authentication=2=

cURL supports both Basic and Digest HTTP authentication methods, among others. The ''CURLOPT_HTTPAUTH'' setting controls the method to use and is set using constants such as ''CURLAUTH_BASIC'' or ''CURLAUTH_DIGEST''. The ''CURLOPT_USERPWD'' setting is a string containing the authentication credentials to use in the format '''username:password'''. Note that this has to be set for each request requiring authentication.

=2=Redirection=2=

''CURLOPT_FOLLOWLOCATION'' can be set to ''true'' to have cURL automatically place process redirections. That is, it will detect Location headers in the server response and implicitly issue requests until the server response no longer contains a Location header. To set the maximum number of Location headers to have cURL process automatically before terminating, use the ''CURLOPT_MAXREDIRS'' setting. To have authentication credentials persist in requests resulting from redirections, set the ''CURLOPT_UNRESTRICTED_AUTH'' setting to true.

=2=Referers=2=

''CURLOPT_REFERER'' allows you to explicitly set the value of the Referer header. Setting ''CURLOPT_AUTOREFERER'' to ''true'' will cause cURL to automatically set the value of the Referer header whenever it processes a Location header.

=2=Content Caching=2=

''CURLOPT_TIMECONDITION'' must be set to either ''CURL_TIMECOND_IFMODSINCE'' or ''CURL_TIMECOND_IFUNMODSINCE'' to select whether the If-Modified-Since or If-Unmodified-Since header will be used respectively. 

''CURLOPT_TIMEVALUE'' must be set to a UNIX timestamp (a date representation using the number of seconds between the UNIX epoch and the desired date) to indicate the last client access time of the resource. The ''time'' function can be used to derive this value.

=2=User Agents=2=

''CURLOPT_USERAGENT'' can be used to set the User Agent string to use.

=2=Byte Ranges=2=

''CURLOPT_RESUME_FROM'' can be used to set a single point within the document from which to start the response body. This will cause the Range header to be set with a value of X- where X is the specified starting point. 

In order to specify multiple ranges, ''CURLOPT_RANGE'' accepts a string in the same format as the Range header (X-Y or X-).

=2=DNS Caching=2=

You may notice that code using the cURL extension appears to run faster than code using streams. The reason for this is that cURL implements its own DNS cache, which is more likely to be apparent if your operating system or internet service provider does not provide one.

DNS, or Domain Name System, is a system used to derive an IP address for a domain name in a manner similar to how phone directories are used to obtain a phone number for a person using their name. The process of obtaining an IP address for a domain name, called a DNS lookup, can be a costly operation in terms of the time required.

Because the results of DNS lookups don't change often, DNS caching is often used to retain the results of lookups for a certain time period after they are performed. This can be done at multiple levels including the source code level as with cURL, the OS level either natively or via software like nscd or dnsmasq, or at the Internet Service Provider (ISP) level.

cURL DNS caching is enabled by default. Some situations like debugging may warrant disabling it, which can be done by setting ''CURLOPT_DNS_USE_GLOBAL_CACHE'' to ''false''. cURL will also by default retain the results of DNS lookups in memory for two minutes. To change this, set the ''CURLOPT_DNS_CACHE_TIMEOUT'' setting to the number of seconds a result should remain in the cache before expiring.

Also noteworthy is the fact that cURL DNS caching is not thread-safe. Threading is a particular style of parallel processing. The most common implementation of threading consists of multiple threads of execution contained within a single operating system process that share resources such as memory. Because of this, it may operate unpredictably in a threaded environment such as Windows Server or *NIX running a threaded Apache MPM. 

If you are using the HTTP streams wrapper or either of the PHP-based HTTP client libraries covered in this chapter and you have access to install software on your server, you may want to install a local DNS caching daemon to improve performance. Try nscd or dnsmasq on *NIX. Writing DNS caching into your own client will be covered later in this section.

=2=Timeouts=2=

''CURLOPT_CONNECTTIMEOUT'' is a maximum amount of time in seconds to which a connection attempt will be restricted for a cURL operation. It can be set to 0 to disable this limit, but this is inadvisable in a production environment. Note that this time includes DNS lookups. For environments web the DNS server in use or the web server hosting the target application is not particularly responsive, it may be necessary to increase the value of this setting.

''CURLOPT_TIMEOUT'' is a maximum amount of time in seconds to which the execution of individual cURL extension function calls will be limited. Note that the value for this setting should include the value for ''CURLOPT_CONNECTTIMEOUT''. In other words, ''CURLOPT_CONNECTTIMEOUT'' is a segment of the time represented by ''CURLOPT_TIMEOUT'', so the value of the latter should be greater than the value of the former.

=2=Request Pooling=2=

Because it is written C, the cURL extension has one feature that cannot be replicated in libraries written in PHP: the ability to run multiple requests in parallel. What this means is that multiple requests can be provided to cURL all at once and, rather than waiting for a response to be received for the first request moving onto sending the second, all requests will be sent and processed as responses are returned. This can significantly shorten the time required to collectively complete all the requests. However, care should be taken not to overload a single host with requests when using this.

<code php>
<?php
$ch1 = curl_init('http://localhost.example/resource1');
curl_setopt($ch1, CURLOPT_RETURNTRANSFER, true);
/* other curl_setopt calls */

$ch2 = curl_init('http://localhost.example/resource2');
curl_setopt($ch2, CURLOPT_RETURNTRANSFER, true);
/* other curl_setopt calls */

$mh = curl_multi_init();
curl_multi_add_handle($mh, $ch1);
curl_multi_add_handle($mh, $ch2);

$running = null;
do {
    curl_multi_exec($mh, $running);
} while ($running > 0);

$ch1_response = curl_multi_getcontent($ch1);
$ch2_response = curl_multi_getcontent($ch2);

curl_multi_remove_handle($ch1);
curl_close($ch1);

curl_multi_remove_handle($ch2);
curl_close($ch2);

curl_multi_close($mh);
</code>

- Two cURL session handles ''$ch1'' and ''$ch2'' are initialized and configured normally. Note that more than two can be used in this type of operation; two merely satisfy the purpose of this example.
- A cURL multi handle ''$mh'' is initialized and the two session handles are added to it.
- A loop is used in conjunction with the flag ''$running'' to repeatedly check (i.e. poll) the multi handle for completion of all contained operations.
- ''curl_multi_getcontent'' is used on the two session handles to get the response bodies of each.
- The session handles are individually removed from the multi handle and closed using ''curl_multi_remove_handle'' and ''curl_close'' respectively.
- The multi handle is closed using ''curl_multi_close''.

=1=pecl_http PECL Extension=1=

The pecl_http extension became available in PHP 5 and gained a class for HTTP responses in PHP 5.1. Like the cURL extension, it also wraps the libcurl library and has similar advantages as a result, such as its internal DNS cache. While the cURL extension uses resources and configuration options to more closely mimic libcurl's own API, the pecl_http extension offers the same features in the form of procedural and object-oriented APIs. As a result, code that uses pecl_http is generally shorter than equivalent code using the cURL extension.

Another major difference is that the cURL extension is considered to be part of the PHP core, which means that it is more likely to be present in most environments supporting PHP. In contrast, pecl_http must be installed via the pecl installer or compiled manually from source. In either case, the extension requires the PHP and libcurl development headers to be present in order to compile properly. Not technically being part of the PHP core, it is less likely to be present or available in shared hosting environments depending on the hosting provider. This may be a concern for code that is intended to be distributed for use in a variety of environments.

To install pecl_http via the pecl installer, PEAR must be installed. See http://pear.php.net/manual/en/installation.php. A package for PEAR may also be available through your OS package manager. Once it is installed, simply issue the command ''pecl install pecl_http''. To install from source, download the latest version from http://pecl.php.net/get/pecl_http. Note that this requires the header files for the PHP version you are using, which are contained in the PHP source tarballs available for download at http://www.php.net/downloads.php or possibly also through your OS package manager.

=2=Back to Basics=2=

<code php>
<?php
// Procedural
$response = http_get('http://localhost.example', null, $info);

// Object-oriented
$request = new HttpRequest('http://localhost.example');
$response = $request->send();
</code>

- After the ''http_get'' call, ''$response'' will be a string containing the body of the response and ''$info'' will contain an associative array with information about the request and response. ''null'' is used in place of an array of request options that will be covered in more detail shortly.
- The ''HttpRequest'' block is an object-oriented equivalent of the ''http_get'' procedural call and offers a more explicit (albeit slightly less concise) API for setting and getting data about the request and response.
- The constructor for the ''HttpRequest'' class has two additional parameters than those shown here, a constant representing the request method (the default is ''HTTP_METH_GET'' for a GET request) and an associative array of request options as included in the ''http_get'' block.

=2=Moving On=2=

<code php>
<?php
$data = array(
    'param1' => 'value1',
    'param2' => 'value2'
);

$files = array(
    array(
        'name' => 'file1',
        'type' => 'image/jpeg',
        'file' => '/path/to/file1.jpg'
    ),
    array(
        'name' => 'file2',
        'type' => 'image/gif',
        'file' => '/path/to/file2.gif'
    )
);

$options = array(
    'referer' => 'http://localhost.example/'
);

// Procedural
$response = http_post_fields(
    'http://localhost.example/process', 
    $data, 
    $files, 
    $options, 
    $info
);

// Object-oriented
$request = new HttpRequest();
$request->setUrl('http://localhost.example/process');
$request->setMethod(HTTP_METH_POST);
$request->setPostFields($data);
$request->setPostFiles($files);
$request->setOptions($options);
$response = $request->send();
</code>

- ''http_post_fields'', ''setPostFields'', and ''setPostFiles'' are used to set the request method to POST and to specify that the extension should handle constructing and encoding the POST body with the provided data. If you are handling this aspect of the request yourself, use ''http_post_data'' or ''setRawPostData'' instead.
- ''setUrl'' is used to set the URL of the HttpRequest instance rather than the constructor, just as an example.
- After ''HttpRequest'' is instantiated, its request method is explicitly set using the constant ''HTTP_METH_POST''. 
- Request options are passed in this time, specifically the value for the Referer header. They are specified as the fourth parameter of ''http_post_fields'' and via ''setOptions''.
- As with the GET request, the return values of ''http_post_fields'' and ''send'' are of the same types (string and HttpMessage) as their respective counterparts in the earlier GET example.

{{Alternative Methods and More Options

For request method constants beyond GET and POST used by the procedural API, see http://php.net/manual/en/http.constants.php.
For more on available request options for both APIs, see http://php.net/manual/en/http.request.options.php.}}

=2=Handling Headers=2=

When using the procedural API, limited request header information is available via the ''$info'' parameter of functions to issue requests. Response headers are included in the string returned by those function calls. When the string is passed to ''http_parse_message'', it returns an object with a ''headers'' property, which is an associative array of header values indexed by header name.

Custom request headers can be set via the ''headers'' request option, which is formatted as an associative array with header names for keys pointing to corresponding header values (as opposed to cURL, which uses an enumerated array with one header name-value pair per array item). Below is an example of custom headers in a request options array.

<code php>
<?php
$opts = array(
    'headers' => array(
        'User-Agent' => 'Mozilla/5.0 (X11; U; ...',
        'Connection' => 'keep-alive'
    )
);
$request = new HttpRequest();
$request->setOptions($opts);
</code>

The object-oriented API offers several slightly less cumbersome solutions as shown in the examples below.

<code php>
<?php
$request = new HttpRequest();
// configure $request
$request->send();

// only returns custom set request headers
print_r($request->getHeaders());

// returns all request headers
$requestmessage = $request->getRequestMessage();
print_r($requestmessage->getHeaders());

// returns a specific request header
echo $requestmessage->getHeader('User-Agent');

// both return all response headers
$responsemessage = $request->getResponseMessage();
print_r($responsemessage->getHeaders());
print_r($request->getResponseHeader());

// both return a single response header
echo $responsemessage->getHeader('Content-Length');
echo $request->getResponseHeader('Content-Length');
</code>

=2=Debugging Requests=2=

Debugging transmitted requests and responses with pecl_http is actually pretty simple. Configure and send a request, then call the ''getRawRequestMessage'' and ''getRawResponseMessage'' methods on the request instance as shown below.

<code php>
<?php
$request = new HttpRequest('http://localhost.example/index.php');
// configure $request
$request->send();

// returns a string containing the entire request
echo $request->getRawRequestMessage();

// returns a string containing the entire response
echo $request->getRawResponseMessage();
</code>

=2=Timeouts=2=

As with cURL, pecl_http has options for handling timeouts. 

The ''timeout'' request option, which corresponds to ''CURLOPT_TIMEOUT'', is the maximum number of seconds an entire request may take before timing out.

Likewise the ''connecttimeout'' request option, the counterpart for ''CURLOPT_CONNECTTIMEOUT'', is the maximum number of seconds that a connection attempt, which includes DNS resolution, may take.

Finally the ''dns_cache_timeout'' request option, which is equivalent to ''CURLOPT_DNS_CACHE_TIMEOUT'', is the maximum number of seconds that a DNS cache entry will be retained and defaults to 120 seconds (two minutes).

=2=Cookies=2=

<code php>
<?php
$requestcookies = array(
    'foo' => 'foovalue',
    'bar' => 'barvalue'
);

$cookiejar = '/path/to/cookiejar';

// Procedural
$options = array(
    'cookie' => $requestcookies, 
    // - OR -
    'cookiestore' => $cookiejar 
);

$response = http_get('http://localhost.example', $options);
$parsedresponse = http_parse_message($response);
$responsecookies = array_map(
    'http_parse_cookie', 
    $parsedresponse->headers['Set-Cookie']
);

// Object-oriented
$request = new HttpRequest('http://localhost.example');
$request->enableCookies();
$request->setCookies($cookies);
$request->addCookies(array('baz' => 'bazvalue'));
$request->send();
$responsecookies = $request->getResponseCookies();
</code>

- Like cURL, pecl_http allows cookie data to be specified manually. Unlike cURL, pecl_http handles most of the formatting for you. Simply specify an associative array of cookie name-value pairs for the ''cookie'' request option. If your cookie values are already encoded, set the ''encodecookies'' request option to ''false''.
- Also like cURL, pecl_http includes an option to use a file for storing cookie data. Unlike cURL, pecl_http always uses the same file for both read and write operations. That is, it consolidates the ''CURLOPT_COOKIEFILE'' and ''CURLOPT_COOKIEJAR'' options into the ''cookiestore'' request option.
- Because the procedural API lacks the persistent scope that is a defining characteristic of the object-oriented API, extracting cookie values for uses beyond storage and persistence is somewhat involved. ''http_parse_message'' is used to parse the headers and body from a string containing an HTTP response message into an object for easier access. ''http_parse_cookie'' is then applied to Set-Cookie header values to parse the cookie data from them.
- In ''HttpRequest'' the ''enableCookies'' method explicitly sets ''CURLOPT_COOKIEFILE'' to an empty string so that cookie data is persisted in memory. ''setCookies'' accepts an associative array of cookie name-value pairs just like the ''cookie'' request option. ''addCookies'' does the same thing, but merges the array contents into any existing cookie data rather than deleting the latter as ''setCookies'' does.
- Once the ''send'' method is called on ''$request'', cookie data from the response is retrieved by calling the ''getResponseCookies'' method.

=2=HTTP Authentication=2=

The ''httpauth'' request option is used to set credentials in the format ''username:password''. The type of HTTP authentication to use is specified via the ''httpauthtype'' request option using one of the pecl_http ''HTTP_AUTH_*'' constants, which are similar to those intended for the same purpose in the cURL extension. 

Lastly, ''unrestrictedauth'' can be set to ''true'' if authentication credentials should be included in requests resulting from redirections pointing to a different host from the current one.

=2=Redirection and Referers=2=

Intuitively, the ''redirect'' request option is used to set the maximum number of redirections to process before automatically terminating. Not so intuitively, it defaults to 0, which means that processing of redirections is disabled and you must explicitly set this request option to a value greater than 0 to enable it. 

The ''referer'' request option can be used to set the value of the Referer request header. Alternatively, it can be set via the ''headers'' request option (more on that shortly) when using the procedural API or the ''setHeaders'' and ''addHeaders'' methods of the ''HttpRequest'' class when using the object-oriented API.

=2=Content Caching=2=

The ''lastmodified'' request option accepts a UNIX timestamp to be used as the value for the If-Modified-Since or If-Unmodified-Since request header. 

Likewise, the ''etag'' request option accepts a string to be used as the value for the If-Match or If-None-Match request header.

=2=User Agents=2=

The ''useragent'' request option can be used to set a custom user agent string for the request. 

=2=Byte Ranges=2=

Like cURL, pecl_http includes request options for a single resume point and multiple byte ranges. The former is ''resume'' and accepts an integer for the starting point. The latter is ''range'' and is formatted as an array of enumerated arrays each containing a pair of integers representing a single byte range. What follows is an example of setting byte ranges within a request options array.

<code php>
<?php
$opts = array(
    'range' => array(
        array(1, 1024), // bytes 1-1024, i.e. the first KB
        array(3073, 4096) // bytes 3073-4096, i.e. third KB
    )
);
</code>

Alternatively, it can be set using custom headers via the ''headers'' request option, which is formatted as an associative array with header names for keys pointing to corresponding header values (as opposed to cURL, which uses an enumerated array with one header name-value pair per array item). Below is an example of custom headers in a request options array.

<code php>
<?php
$opts = array(
    'headers' => array(
        'User-Agent' => 'Mozilla/5.0 (X11; U; ...',
        'Connection' => 'keep-alive'
    )
);
</code>

=2=Request pooling=2=

pecl_http also inherits cURL's support for request pooling, or sending and processing multiple requests in parallel. Like other features, pecl_http implements it in a more succinct fashion. Oddly enough, it is one feature that is limited to pecl_http's object-oriented API and has no equivalent in its procedural API. It is implemented in the form of the ''HttpRequestPool'' class.

<code php>
<?php
$request1 = new HttpRequest();
// configure $request1

$request2 = new HttpRequest();
// configure $request2

$request3 = new HttpRequest();
// configure $request3

$pool = new HttpRequestPool($request1, $request2);
$pool->attach($request3);
$pool->send();
</code>

- The ''HttpRequestPool'' constructor accepts a variable number of arguments, all of which should be preconfigured ''HttpRequest'' instances.
- Request instances can also be added via the ''attach'' method of the ''HttpRequestPool'' class.
- ''send'' is called on the pool instance to transmit all requests and blocks until all responses are received. Once complete, all request instances contain their respective sets of response data as if they had been sent individually.

{{pecl_http in the PHP Manual

For more information on the pecl_http extension, see http://php.net/http.
For more information on its request options, http://php.net/manual/en/http.request.options.php.}}

=1=PEAR::HTTP_Client=1=

The PHP Extension and Application Repository (PEAR) project houses a library of reusable components written in PHP and a package system for distributing them, one of which is the ''HTTP_Client'' package that will be covered in the sections to follow. PEAR spurred the creation of the PECL project, a repository of C extensions from which the pecl_http extension discussed in the previous section originates.

One trait of many components in PEAR is backward compatibility with older versions of PHP. The ''HTTP_Client'' package itself only requires 4.3.0, while the latest and last version of the PHP 4 branch is 4.4.9. As such, this client may be a good solution when feature requirements are more advanced than what the HTTP streams wrapper natively supports and the intended runtime environment is restricted to an older PHP version. Otherwise, if you still want an HTTP client written in PHP, have a look at Zend_Http_Client as described in the next section. It should go without saying that support for PHP 4.x has ceased and that it is highly advisable to run a more current stable version of PHP in production environments.

PHP source tarballs includes a configure option to include PEAR when compiling. Some operating systems may have a package for PEAR apart from PHP itself. Once PEAR is installed, ''pear install HTTP_Client'' should be sufficient to install ''PEAR::HTTP_Client''. There is also the option to manually download tarballs for the necessary PEAR packages (''HTTP_Client'', ''HTTP_Request'', ''Net_URL'', and ''Net_Socket''), though this is more difficult to maintain in the long term as updates are released.

{{PEAR Developments

At the time of writing, efforts are being put into PEAR 2, the successor to the current incarnation of the PEAR project. This will include a newer package distribution system and ports or revamps of many existing packages to bring them up-to-date with features available in PHP 5. However, because there is currently little in the way of stable ported code for PEAR 2, coverage in this book will be limited to PEAR 1. }}

=2=Requests and Responses=2=

There are two ways to perform HTTP requests with the related PEAR components: ''HTTP_Request'' and ''HTTP_Client''. The latter composes the former to add capabilities such as handling redirects and persisting headers, cookie data, and request parameters across multiple requests. Here's how to perform a simple request and extract response information when using ''HTTP_Request'' directly. 

<code php>
<?php
require_once 'HTTP/Request.php';

$request =& HTTP_Request('http://localhost.example');
$request->setMethod(HTTP_REQUEST_METHOD_GET);
$request->setURL('http://localhost.example');
$response = $request->sendRequest();
</code>

- The ''HTTP_Request'' constructor has two parameters, both of which are optional. The first is a string containing the URL for the request; note that the ''setURL'' method is an alternative way to specify a value for this. The second is a parameters array, which will be discussed later. 
- By default, the GET method is used. ''setMethod'' is used to change this using constants, the names for which are formed by prefixing the desired request method with ''HTTP_REQUEST_METHOD_'' as in ''HTTP_REQUEST_METHOD_GET''.
- ''sendRequest'' intuitively dispatches the request and obtains the response. It returns either ''true'' to indicate that that request succeeded or an error object (of the ''PEAR_Error'' class by default) if an issue occurred.

Issues that cause errors include environmental requirements of the component not being met or the target of the request exceeding the redirect limit. ''PEAR::isError'' is used to determine if the ''sendRequest'' call resulted in an error. If the request is sent successfully, several methods of the request object are available to extract response information.

<code php>
<?php
if (!PEAR::isError($response)) {
    $code = $request->getResponseCode();
    $reason = $request->getResponseReason();
    $body = $request->getResponseBody();
    $cookies = $request->getResponseCookies();
    $headers = $request->getResponseHeader();
    $contentType = $request->getResponseHeader('Content-Type');
}
</code>

A few specifics about the response information methods: 
- ''getResponseCode'' returns an integer containing the HTTP status code.
- ''getResponseReason'' returns a string containing a description that corresponds to the HTTP status code.
- ''getResponseCookies'' returns ''false'' if no cookies are set; otherwise it returns an enumerated array of associative arrays each of which contains information for an individual cookie such as its name, value, and expiration date. 
- ''getResponseHeader'' will return an associative array of all headers indexed by header name (in all lowercase) if no parameter is passed to it; otherwise, it takes a single string parameter containing a specific header name for which it will return the value.

''sendRequest'' does not modify any parameters set by you that are specific to the request (as opposed to the response). That is, request instances can be reused and individual parameters modified only as needed to change what differs between consecutive requests. To "start fresh" with an existing request instance, simply explicitly call its constructor method.

<code php>
<?php
$request =& new HTTP_Request;
// ...
$request->HTTP_Request();
// all parameters previously set will be cleared
</code>

=2=Juggling Data=2=

''HTTP_Request'' makes data management pretty easy and straightforward, so it's all covered in this section.

<code php>
<?php
$request =& new HTTP_Request('http://localhost.example');

// GET
$request->addQueryString('variable', 'value');
$request->addRawQueryString('foo=bar');

// POST
$request->addPostData('variable', 'value');
$request->clearPostData();

// COOKIE
$request->addCookie('variable', 'value');
$request->clearCookies();

// FILES
$request->addFile('fieldname', '/path/to/file', 'text/plain');
</code>

- ''addRawQueryString'' isn't named very intuitively, as it actually overwrites any query string that you've previously set.
- By default, ''addQueryString'' and ''addPostData'' will URL encode the variable value. To prevent this if your data is already preencoded, pass the value ''true'' as the third parameter to either method.
- ''clearPostData'' and ''clearCookies'' reset internal variables used to store data passed in by ''addQueryString'' and ''addPostData'' respectively.
- ''setURL'' and ''addQueryString'' or ''addRawQueryString'' can be used together to control the content of the internal variable for the URL of the request. ''getURL'' can be used to see the effects of these during development.
- ''addFile'' is intended to simulate uploading a file via a file input field in an HTML form. For forms with multiple file upload files with the same name, pass an array of file paths as the second parameter and (optionally) an array of corresponding file MIME types as the third parameter. 
- To send the contents of a file as the entire body of a request, use ''file_get_contents'' to retrieve the file contents into a string and pass that to the ''setBody'' method of the request instance.

=2=Wrangling Headers=2=

Handling headers is also relatively straightforward. The only header-specific convenience method that's included is for handling Basic HTTP authentication, as shown below.

<code php>
<?php
$request =& new HTTP_Request;
$request->addHeader('name', 'value');
$request->removeHeader('name');
$request->setBasicAuth('username', 'password');
</code>

=2=Using the Client=2=

''HTTP_Client'' persists explicit sets of headers and requests parameters across multiple requests, which are set using the ''setDefaultHeader'' and ''setRequestParameter'' methods respectively. The client constructor also accepts arrays of these. Default headers and request parameters can be cleared by calling ''reset'' on the client instance.

Internally, the client class actually creates a new instance of ''HTTP_Request'' per request. The request operation is set depending on which of the client instance methods are called; ''get'', ''head'', and ''post'' are supported.

The capabilities of the client described up to this point can all be accomplished by reusing the same request instance for multiple requests. However, the client also handles two things that the request class does not: cookies and redirects.

By default, cookies are persisted automatically across requests without any additional configuration. ''HTTP_Client_CookieManager'' is used internally for this. For custom cookie handling, this class can be extended and an instance of it passed as the third parameter to the client constructor. If this is done, that instance will be used rather than an instance of the native cookie manager class being created by default.

The maximum number of redirects to process can be set using the ''setMaxRedirects'' method of the client class. Internally, requests will be created and sent as needed to process the redirect until a non-redirecting response is received or the maximum redirect limit is reached. In the former case, the client method being called will return an integer containing the response code rather than ''true'' as the request class does. In the latter case, the client method will return an error instance.

To retrieve information for the last response received, use the ''currentResponse'' method of the client instance. It will return an associative array containing the keys '''code''', '''headers''', and '''body''' with values corresponding to the return values of request methods ''getResponseCode'', ''getResponseHeader'', and ''getResponseBody'' respectively.

By default, all responses are stored and can be accessed individually as shown below. To disable storage of responses all except the last one, call ''enableHistory'' on the client instance and pass it ''false''.

<code php>
<?php
for ($client->rewind(); $client->valid(); $client->next()) {
    $url = $client->key();
    $response = $client->current();
}
</code>

=2=Observing Requests=2=

@todo http://pear.php.net/manual/en/package.http.http-client.http-client.attach.php

Both ''HTTP_Request'' and ''HTTP_Client'' have ''attach'' and ''detach'' methods for adding and removing instances of ''HTTP_Request_Listener''. This class implements the observer design pattern and serves to intercept events that occur during the process of transmitting a request and receiving a response. To create an observer, first create a class that extends ''HTTP_Request_Listener'' as shown below.

<code php>
<?php
class Custom_Request_Listener extends HTTP_Request_Listener
{
    function Custom_Request_Listener()
    {
        $this->HTTP_Request_Listener();
    }

    function update(&$subject, $event, $data = null)
    {
        switch ($event) {
            // Request events
            case 'connect':     // ...
            case 'sentRequest': // ...
            case 'disconnect':  // ...

            // Response events
            case 'gotHeaders':  // ...
            case 'tick':        // ...
            case 'gztick':      // ...
            case 'gotBody':     // ...

            default:
                PEAR::raiseError('Unhandled error: ' . $event);
        }
    }
}
</code>

- Declare a constructor that at minimum calls the parent constructor.
- Declare the ''update'' method with the signature shown. ''$subject'' is the request or client instance to which the listener is attached. ''$event'' is a string containing one of the events shown in the ''switch'' statement. (Note that not all events need to be handled, only those with which you are concerned.) ''$data'' is data specific to events related to reception of the server response.

{{PEAR References

For more information on the PEAR packages covered here, see these resources:
- http://pear.php.net/manual/en/package.http.http-request.php 
- http://pear.php.net/manual/en/package.http.http-client.php 
- http://pear.php.net/manual/en/package.http.http-request.listeners.php}} 

=1=Zend_Http_Client=1=

=1=Rolling Your Own=1=
